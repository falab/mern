{"version":3,"sources":["application.min.js","zframe.js","controllers/home_controller.js","modules/main.js","modules/zRouter.js"],"names":["_typeof","Symbol","iterator","obj","constructor","window","Zframe","cacheElements","_elements","app","document","getElementById","moduleRegistered","modName","Object","key","_modules","unloaded","indexOf","moduleLoaded","keys","loaded","loadModule","modData","fn","scope","hasOwnProperty","modFn","pop","dependencies","zframe","logger","error","undefined","forEach","depName","i","push","scopes","apply","info","name","loadModules","initializeControllers","_controllers","init","_info","version","_prototypes","controller","deps","isValid","this","Array","isArray","loadDeps","length","module","warn","methods","log","console","arguments","message","table","xhr","options","url","trigger","el","evtType","spec","querySelector","e","Event","bubbles","cancelable","dispatchEvent","bindEvent","query","addEventListener","matches","prototype","slice","call","querySelectorAll","target","extend","obj1","obj2","contName","create","concat","zRouter","index","data","menuItems","path","text","remote","innerHTML","Templates","application","addRoute","routeSpec","routes","defaultRoute","getRouteByPath","route","every","routeName","processRoute","home","action","template","portfolio","hasAttribute","targetRoute","getAttribute","preventDefault","history","pushState","state","when","otherwise"],"mappings":"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","file":"application.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nwindow.Zframe = function () {\n  var _info = {\n    name: 'Zframe',\n    version: '0.0.0'\n  };\n  var _data = {};\n  var _cache = {};\n  var _modules = {\n    loaded: {},\n    unloaded: {},\n    scopes: {}\n  };\n  var _controllers = {};\n  var _fn = {};\n  var _elements = {};\n  var _prototypes = {};\n\n  _prototypes.controller = {\n    name: null,\n    fn: null,\n    deps: [_elements],\n    isValid: function isValid() {\n      if (typeof this.name !== 'string') return false;\n      if (typeof this.fn !== 'function') return false;\n      if (!Array.isArray(this.deps)) return false;\n      return true;\n    },\n    loadDeps: function loadDeps() {\n      // intentionally starting at 1 to skip the elements hash\n      for (var i = 1; i < this.deps.length; i++) {\n        var modName = this.deps[i];\n        var module = _modules.loaded[modName];\n\n        if (module === undefined) {\n          zframe.logger.warn('controller \\'' + this.name + '\\' dependency \\'' + modName + '\\' is not a loaded module.');\n        }\n\n        this.deps[i] = module;\n      }\n    },\n    init: function init() {\n      if (!this.isValid()) {\n        return false;\n      }\n\n      this.loadDeps();\n      this.methods = this.fn.apply(this, this.deps);\n\n      zframe.logger.info('controller \\'' + this.name + '\\' initialized.');\n\n      return true;\n    }\n  };\n\n  var zframe = {};\n\n  function cacheElements() {\n    _elements.app = document.getElementById('app');\n  }\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    var modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      var modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if ((typeof modData === 'undefined' ? 'undefined' : _typeof(modData)) !== \"object\") {\n      zframe.logger.error('module \\'' + modName + '\\' could not be loaded.');\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    var dependencies = [_elements];\n\n    // TODO: handle 'call stack exceeded' if it shows up\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach(function (depName, i) {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            zframe.logger.error('module \\'' + modName + '\\' dependency \\'' + depName + '\\' is not a registered module.');\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    zframe.logger.info('module \\'' + modName + '\\' loaded!');\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach(function (modName) {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  function initializeControllers() {\n    Object.keys(_controllers).forEach(function (key) {\n      _controllers[key].init();\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  zframe.logger = {\n    log: function log() {\n      console.log.apply(console, arguments);\n    },\n    info: function info(message) {\n      console.info(_info.name + ': ' + message);\n    },\n    warn: function warn(message) {\n      console.warn(_info.name + ': ' + message);\n    },\n    error: function error(message) {\n      console.error(_info.name + ': ' + message);\n    },\n    table: function table() {\n      console.table.apply(console, arguments);\n    }\n  };\n\n  // TODO: write xhr utility\n  zframe.xhr = function () {\n    return function (options) {\n      if (typeof options === \"string\") {\n        options = {\n          url: options\n        };\n      }\n\n      zframe.logger.info('performing XHR to \\'' + options.url + '\\' here.');\n    };\n  };\n\n  zframe.trigger = function (el, evtType, spec) {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    var e = new Event(evtType, {\n      bubbles: false,\n      cancelable: false\n    });\n\n    el.dispatchEvent(e);\n  };\n\n  // Binds an event to an element, support delegation\n  zframe.bindEvent = function (el, evtType, spec, fn) {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    if (fn === undefined) {\n      if (typeof spec === \"function\") {\n        fn = spec;\n      } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === \"object\") {\n        fn = spec.fn;\n      }\n    }\n\n    var query = undefined;\n\n    if (typeof spec === \"string\") {\n      query = spec;\n    } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === \"object\") {\n      query = spec.query;\n    }\n\n    if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === undefined) {\n      app.logger.error('couldn\\'t find an event to bind');\n    }\n\n    if (query === undefined) {\n      el.addEventListener(evtType, fn);\n    } else {\n      el.addEventListener(evtType, function (e) {\n        var matches = Array.prototype.slice.call(el.querySelectorAll(query));\n\n        if (matches.indexOf(e.target) !== -1) {\n          fn.apply(this, arguments);\n        }\n      });\n    }\n  };\n\n  // Add the properties of one object to another, shallow copy\n  zframe.extend = function (obj1, obj2) {\n    if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach(function (key) {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  zframe.module = function (modName, modData) {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        zframe.logger.warn('module \\'' + modName + '\\' already registered for loading.');\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return zframe;\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      return zframe.logger.error('module \\'' + modName + '\\' doesn\\'t exist.');\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Method for registering and returning controllers\n  zframe.controller = function (contName, spec) {\n    if (spec !== undefined) {\n      if (Object.keys(_controllers).indexOf(contName) !== -1) {\n        zframe.logger.warn('controller \\'' + contName + '\\' already loaded.');\n        return zframe;\n      }\n\n      var controller = Object.create(_prototypes.controller);\n      controller.name = contName;\n\n      if (typeof spec === 'function') {\n        controller.fn = spec;\n      } else if (Array.isArray(spec)) {\n        controller.fn = spec.pop();\n        controller.deps = controller.deps.concat(spec);\n      } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === 'object') {\n        zframe.extend(controller.prototype, spec);\n      }\n\n      _controllers[contName] = controller;\n\n      return zframe;\n    }\n\n    if (Object.keys(_controllers).indexOf(contName) === -1) {\n      return zframe.logger.error('controller \\'' + contName + '\\' doesn\\'t exist.');\n    }\n\n    return _controllers[contName];\n  };\n\n  // Initializes all of the modules\n  zframe.init = function () {\n    cacheElements();\n    loadModules();\n    initializeControllers();\n\n    zframe.logger.info('initialization complete.');\n  };\n\n  return zframe;\n};\n\nwindow.zframe = Zframe();\n'use strict';\n\nzframe.controller('HomeController', ['zRouter', function (_elements, zRouter) {\n  return {\n    index: function index() {\n      zframe.logger.info('HomeController index method ran');\n      zframe.logger.log(_elements, zRouter);\n    }\n  };\n}]);\n'use strict';\n\nzframe.module('main', function (_elements) {\n  var data = {\n    menuItems: [{ path: '/', text: 'home' }, { path: '/portfolio', text: 'portfolio' }, { path: 'http://www.google.com', text: 'Google', remote: true }]\n  };\n\n  _elements.app.innerHTML = zframe.Templates.application(data);\n});\n'use strict';\n\n/**\n * Verbiage note: \"routeSpec\" is the route definition BEFORE adding to routes, still allowed to be changed\n * \"route\" is the route definition as returned from the routes hash, not allowed to be modified at this point\n */\nzframe.module('zRouter', function (_elements) {\n  // Hash of all app routes\n  var routes = {\n    'home': {\n      path: '/',\n      controller: 'homeController',\n      action: 'show',\n      template: 'home'\n    },\n    'portfolio': {\n      path: '/portfolio',\n      controller: 'portfolioController',\n      action: 'index',\n      template: 'portfolio'\n    }\n  };\n\n  // Pushes a routeSpec into the routes hash with specified name\n  function addRoute(name, routeSpec) {\n    // Early return if path isn't a string\n    if (typeof routeSpec.path !== 'string') {\n      zframe.logger.warn('Route \\'' + name + '\\' couldn\\'t be added, path couldn\\'t be processed.');\n      return;\n    }\n\n    // prepend a slash to path if it doesn't already start with one\n    if (routeSpec.path[0] !== '/') {\n      routeSpec.path = '/' + routeSpec.path;\n    }\n\n    // add routeSpec to routes hash\n    routes[name] = routeSpec;\n  }\n\n  // Pushes a routeSpec object into the routes hash with a path of /\n  function defaultRoute(routeSpec) {\n    return addRoute('default', zframe.extend(routeSpec, { path: '/' }));\n  }\n\n  // Returns the first route that matches a path\n  function getRouteByPath(path) {\n    var route = undefined;\n\n    // Loop through routes and break on first match (screw your 'for' loop.)\n    Object.keys(routes).every(function (routeName) {\n      if (routes[routeName].path === path) {\n        route = routes[routeName];\n        return false;\n      }\n\n      return true;\n    });\n\n    return route;\n  }\n\n  // TODO: Processes a route object and routes the user accordingly\n  function processRoute(route) {\n    zframe.logger.log('Process route \\'' + route.path + '\\'', route);\n  }\n\n  // Bind to all link clicks\n  zframe.bindEvent(_elements.app, 'click', 'a', function (e) {\n    if (!e.target.hasAttribute('href')) {\n      return;\n    }\n\n    var targetRoute = getRouteByPath(e.target.getAttribute('href'));\n\n    if (targetRoute) {\n      e.preventDefault();\n      history.pushState({ route: targetRoute }, '', targetRoute.path);\n      processRoute(targetRoute);\n    }\n  });\n\n  // Bind the popstate event and process routes\n  zframe.bindEvent(window, 'popstate', function (e) {\n    processRoute(e.state.route);\n  });\n\n  // Return the public methods\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});","window.Zframe = function () {\n  let _info = {\n    name: 'Zframe',\n    version: '0.0.0'\n  };\n  let _data = {};\n  let _cache = {};\n  let _modules = {\n    loaded: {},\n    unloaded: {},\n    scopes: {}\n  };\n  let _controllers = {};\n  let _fn = {};\n  let _elements = {};\n  let _prototypes = {};\n\n  _prototypes.controller = {\n    name: null,\n    fn: null,\n    deps: [_elements],\n    isValid: function () {\n      if (typeof this.name !== 'string') return false;\n      if (typeof this.fn !== 'function') return false;\n      if (!Array.isArray(this.deps)) return false;\n      return true;\n    },\n    loadDeps: function () {\n      // intentionally starting at 1 to skip the elements hash\n      for (let i = 1; i < this.deps.length; i++) {\n        let modName = this.deps[i];\n        let module = _modules.loaded[modName];\n\n        if (module === undefined) {\n          zframe.logger.warn(`controller '${this.name}' dependency '${modName}' is not a loaded module.`);\n        }\n\n        this.deps[i] = module;\n      }\n    },\n    init: function () {\n      if (!this.isValid()) {\n        return false;\n      }\n\n      this.loadDeps();\n      this.methods = this.fn.apply(this, this.deps);\n\n      zframe.logger.info(`controller '${this.name}' initialized.`);\n\n      return true;\n    }\n  };\n\n  let zframe = {};\n\n  function cacheElements() {\n    _elements.app = document.getElementById('app');\n  }\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    let modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      let modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if (typeof modData !== \"object\") {\n      zframe.logger.error(`module '${modName}' could not be loaded.`);\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    let dependencies = [_elements];\n\n    // TODO: handle 'call stack exceeded' if it shows up\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach((depName, i) => {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            zframe.logger.error(`module '${modName}' dependency '${depName}' is not a registered module.`);\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    zframe.logger.info(`module '${modName}' loaded!`);\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach((modName) => {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  function initializeControllers() {\n    Object.keys(_controllers).forEach((key) => {\n      _controllers[key].init();\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  zframe.logger = {\n    log: function () {\n      console.log.apply(console, arguments);\n    },\n    info: function (message) {\n      console.info(`${_info.name}: ${message}`);\n    },\n    warn: function (message) {\n      console.warn(`${_info.name}: ${message}`);\n    },\n    error: function (message) {\n      console.error(`${_info.name}: ${message}`);\n    },\n    table: function () {\n      console.table.apply(console, arguments);\n    },\n  };\n\n  // TODO: write xhr utility\n  zframe.xhr = () => {\n    return (options) => {\n      if (typeof options === \"string\") {\n        options = {\n          url: options\n        };\n      }\n\n      zframe.logger.info(`performing XHR to '${options.url}' here.`);\n    };\n  };\n\n  zframe.trigger = (el, evtType, spec) => {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    let e = new Event(evtType, {\n      bubbles: false,\n      cancelable: false\n    });\n\n    el.dispatchEvent(e);\n  };\n\n  // Binds an event to an element, support delegation\n  zframe.bindEvent = (el, evtType, spec, fn) => {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    if (fn === undefined) {\n      if (typeof spec === \"function\") {\n        fn = spec;\n      } else if (typeof spec === \"object\") {\n        fn = spec.fn;\n      }\n    }\n\n    let query;\n\n    if (typeof spec === \"string\") {\n      query = spec;\n    } else if (typeof spec === \"object\") {\n      query = spec.query;\n    }\n\n    if (typeof fn === undefined) {\n      app.logger.error('couldn\\'t find an event to bind');\n    }\n\n    if (query === undefined) {\n      el.addEventListener(evtType, fn);\n    } else {\n      el.addEventListener(evtType, function (e) {\n        let matches = Array.prototype.slice.call(el.querySelectorAll(query));\n\n        if (matches.indexOf(e.target) !== -1) {\n          fn.apply(this, arguments);\n        }\n      });\n    }\n  };\n\n  // Add the properties of one object to another, shallow copy\n  zframe.extend = (obj1, obj2) => {\n    if (typeof obj2 !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach((key) => {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  zframe.module = function (modName, modData) {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        zframe.logger.warn(`module '${modName}' already registered for loading.`);\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return zframe;\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      return zframe.logger.error(`module '${modName}' doesn't exist.`);\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Method for registering and returning controllers\n  zframe.controller = function (contName, spec) {\n    if (spec !== undefined) {\n      if (Object.keys(_controllers).indexOf(contName) !== -1) {\n        zframe.logger.warn(`controller '${contName}' already loaded.`);\n        return zframe;\n      }\n\n      let controller = Object.create(_prototypes.controller);\n      controller.name = contName;\n\n      if (typeof spec === 'function') {\n        controller.fn = spec;\n      } else if (Array.isArray(spec)) {\n        controller.fn = spec.pop();\n        controller.deps = controller.deps.concat(spec);\n      } else if (typeof spec === 'object') {\n        zframe.extend(controller.prototype, spec);\n      }\n\n      _controllers[contName] = controller;\n\n      return zframe;\n    }\n\n    if (Object.keys(_controllers).indexOf(contName) === -1) {\n      return zframe.logger.error(`controller '${contName}' doesn't exist.`);\n    }\n\n    return _controllers[contName];\n  };\n\n  // Initializes all of the modules\n  zframe.init = () => {\n    cacheElements();\n    loadModules();\n    initializeControllers();\n\n    zframe.logger.info('initialization complete.');\n  };\n\n  return zframe;\n};\n\nwindow.zframe = Zframe();\n","zframe.controller('HomeController', ['zRouter', function (_elements, zRouter) {\n  return {\n    index: () => {\n      zframe.logger.info('HomeController index method ran');\n      zframe.logger.log(_elements, zRouter);\n    }\n  };\n}]);\n","zframe.module('main', function (_elements) {\n  let data = {\n    menuItems: [\n      { path: '/', text: 'home' },\n      { path: '/portfolio', text: 'portfolio' },\n      { path: 'http://www.google.com', text: 'Google', remote: true}\n    ]\n  };\n\n  _elements.app.innerHTML = zframe.Templates.application(data);\n});\n","/**\n * Verbiage note: \"routeSpec\" is the route definition BEFORE adding to routes, still allowed to be changed\n * \"route\" is the route definition as returned from the routes hash, not allowed to be modified at this point\n */\nzframe.module('zRouter', function (_elements) {\n  // Hash of all app routes\n  let routes = {\n    'home': {\n      path: '/',\n      controller: 'homeController',\n      action: 'show',\n      template: 'home'\n    },\n    'portfolio': {\n      path: '/portfolio',\n      controller: 'portfolioController',\n      action: 'index',\n      template: 'portfolio'\n    }\n  };\n\n  // Pushes a routeSpec into the routes hash with specified name\n  function addRoute(name, routeSpec) {\n    // Early return if path isn't a string\n    if (typeof routeSpec.path !== 'string') {\n      zframe.logger.warn(`Route '${name}' couldn't be added, path couldn't be processed.`);\n      return;\n    }\n\n    // prepend a slash to path if it doesn't already start with one\n    if (routeSpec.path[0] !== '/') {\n      routeSpec.path = `/${routeSpec.path}`;\n    }\n\n    // add routeSpec to routes hash\n    routes[name] = routeSpec;\n  }\n\n  // Pushes a routeSpec object into the routes hash with a path of /\n  function defaultRoute(routeSpec) {\n    return addRoute('default', zframe.extend(routeSpec, { path: '/' }));\n  }\n\n  // Returns the first route that matches a path\n  function getRouteByPath(path) {\n    let route;\n\n    // Loop through routes and break on first match (screw your 'for' loop.)\n    Object.keys(routes).every((routeName) => {\n      if (routes[routeName].path === path) {\n        route = routes[routeName];\n        return false;\n      }\n\n      return true;\n    });\n\n    return route;\n  }\n\n  // TODO: Processes a route object and routes the user accordingly\n  function processRoute(route) {\n    zframe.logger.log(`Process route '${route.path}'`, route);\n  }\n\n  // Bind to all link clicks\n  zframe.bindEvent(_elements.app, 'click', 'a', function (e) {\n      if (!e.target.hasAttribute('href')) {\n        return;\n      }\n\n      let targetRoute = getRouteByPath(e.target.getAttribute('href'));\n\n      if (targetRoute) {\n        e.preventDefault();\n        history.pushState({ route: targetRoute }, '', targetRoute.path);\n        processRoute(targetRoute);\n      }\n  });\n\n  // Bind the popstate event and process routes\n  zframe.bindEvent(window, 'popstate', function (e) {\n    processRoute(e.state.route);\n  });\n\n  // Return the public methods\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});\n"],"sourceRoot":"/source/"}