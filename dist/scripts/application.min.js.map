{"version":3,"sources":["application.min.js","zframe.js","modules/main.js","modules/router.js"],"names":["_typeof","Symbol","iterator","obj","constructor","window","Zframe","cacheElements","_elements","app","document","getElementById","moduleRegistered","modName","Object","key","_modules","unloaded","indexOf","moduleLoaded","keys","loaded","loadModule","modData","fn","scope","hasOwnProperty","modFn","pop","dependencies","utils","logger","error","_info","name","undefined","forEach","depName","i","push","scopes","apply","info","loadModules","version","ret","log","console","arguments","warn","table","xhr","options","url","zframe","trigger","el","evtType","spec","querySelector","e","Event","bubbles","cancelable","dispatchEvent","bindEvent","q","query","addEventListener","qMatches","Array","prototype","slice","call","querySelectorAll","target","this","extend","obj1","obj2","module","init","data","menuItems","path","text","remote","innerHTML","Templates","application","addRoute","routeSpec","routes","defaultRoute","getRouteByPath","route","every","routeName","processRoute","home","controller","action","template","portfolio","hasAttribute","targetRoute","getAttribute","preventDefault","history","pushState","state","when","otherwise"],"mappings":"AAAA,YAEA,IAAIA,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,GCF1OE,QAAOC,OAAS,WAkBd,QAASC,KACPC,EAAUC,IAAMC,SAASC,eAAe,OACzC,QAGQC,GAAiBC,GACxB,MAAOC,QAAOC,IAAIC,EAASC,UAAUC,QAAQL,GAAW,GACzD,QAGQM,GAAaN,GACpB,MAAOC,QAAOM,KAAKJ,EAASK,QAAQH,QAAQL,GAAW,GACxD,QAGQS,GAAWT,GAClB,GAAIU,GAAUP,EAASC,SAASJ,EAEhC,IAAuB,kBAAZU,GACTA,GACEC,GAAID,EACJE,cAEG,IAAIF,EAAQG,eAAe,UAAW,CAC3C,GAAIC,GAAQJ,EAAQK,KAEpBL,IACEC,GAAIG,EACJE,aAAcN,EACdE,cAEG,IAAuB,YAAL,mBAAPF,GAAO,YAAAvB,QAAPuB,IAEhB,WADAO,GAAMC,OAAOC,MAASC,EAAMC,KAAI,YAAYrB,EAAO,yBAIhDU,GAAQG,eAAe,WAC1BH,EAAQE,SAGV,IAAII,IAAgBrB,EAGS2B,UAAzBZ,EAAQM,cACVN,EAAQM,aAAaO,QAAQ,SAACC,EAASC,GACrC,IAAKnB,EAAakB,GAAU,CAC1B,IAAKzB,EAEH,WADAkB,GAAMC,OAAOC,MAASC,EAAMC,KAAI,YAAYrB,EAAO,iBAAiBwB,EAAO,gCAI7Ef,GAAWe,GACXR,EAAaU,KAAKvB,EAASK,OAAOgB,OAKxCrB,EAASwB,OAAO3B,GAAWU,EAAQE,MACnCT,EAASK,OAAOR,GAAWU,EAAQC,GAAGiB,MAAMlB,EAAQE,MAAOI,GAE3DC,EAAMC,OAAOW,KAAQT,EAAMC,KAAI,YAAYrB,EAAO,mBAE3CG,GAASC,SAASiB,MAC1B,QAGQS,KACP7B,OAAOM,KAAKJ,EAASC,UAAUmB,QAAQ,SAACvB,GACjCM,EAAaN,IAChBS,EAAWT,KAtFjB,GAAIoB,IACFC,KAAM,SACNU,QAAS,SAIP5B,GACFK,UACAJ,YACAuB,WAGEhC,KAEAsB,KACAe,IA4MyD,OAlI5Df,GAIKC,QACJe,IAAK,WACHC,QAAQD,IAAIL,MAAMM,QAASC,YAE7BN,KAAM,WACJK,QAAQL,KAAKD,MAAMM,QAASC,YAE9BC,KAAM,WACJF,QAAQE,KAAKR,MAAMM,QAASC,YAE9BhB,MAAO,WACLe,QAAQf,MAAMS,MAAMM,QAASC,YAE/BE,MAAO,WACLH,QAAQG,MAAMT,MAAMM,QAASC,aAE/BlB,EAGIqB,IAAM,WACV,MAAO,UAACC,GACiB,gBAAZA,KACTA,GACEC,IAAKD,IAITE,OAAOvB,OAAOW,KAAI,qBAAsBU,EAAQC,IAAG,WAIvDvB,EAAMyB,QAAU,SAACC,EAAIC,EAASC,GACV,gBAAPF,KACTA,EAAK9C,SAASiD,cAAcH,GAG9B,IAAII,GAAI,GAAIC,OAAMJ,GAChBK,SAAS,EACTC,YAAY,GAGdP,GAAGQ,cAAcJ,IACjB9B,EAGImC,UAAY,SAACT,EAAIC,EAASC,EAAMlC,GAClB,gBAAPgC,KACTA,EAAK9C,SAASiD,cAAcH,IAGnBrB,SAAPX,IACkB,kBAATkC,GACTlC,EAAKkC,EACoB,YAAL,mBAAJA,GAAI,YAAA1D,QAAJ0D,MAChBlC,EAAKkC,EAAKlC,IAId,IAAI0C,GAAC/B,MAEe,iBAATuB,GACTQ,EAAIR,EACqB,YAAL,mBAAJA,GAAI,YAAA1D,QAAJ0D,MAChBQ,EAAIR,EAAKS,OAGOhC,UAAL,mBAAFX,GAAE,YAAAxB,QAAFwB,KACTf,IAAIsB,OAAOC,MAASC,EAAMC,KAAI,mCAGtBC,SAAN+B,EACFV,EAAGY,iBAAiBX,EAASjC,GAE7BgC,EAAGY,iBAAiBX,EAAS,SAAUG,GACrC,GAAIS,GAAWC,MAAMC,UAAUC,MAAMC,KAAKjB,EAAGkB,iBAAiBR,GAC3B,MAA/BG,EAASnD,QAAQ0C,EAAEe,SACrBnD,EAAGiB,MAAMmC,KAAM5B,cAIrBlB,EAGI+C,OAAS,SAACC,EAAMC,GACpB,MAAoB,YAAL,mBAAJA,GAAI,YAAA/E,QAAJ+E,KAIXjE,OAAOM,KAAK2D,GAAM3C,QAAQ,SAACrB,GACzB+D,EAAK/D,GAAOgE,EAAKhE,KAGZ+D,GARP,QASAjC,EAIEmC,OAAS,SAACnE,EAASU,GAErB,MAAgBY,UAAZZ,GACsD,KAApDT,OAAOM,KAAKJ,EAASC,UAAUC,QAAQL,GACzCiB,EAAMC,OAAOkB,KAAQhB,EAAMC,KAAI,YAAYrB,EAAO,qCAElDG,EAASC,SAASJ,GAAWU,EAGxBP,EAASC,SAASJ,IAI2B,KAAlDC,OAAOM,KAAKJ,EAASK,QAAQH,QAAQL,OACvCiB,GAAMC,OAAOC,MAASC,EAAMC,KAAI,YAAYrB,EAAO,oBAI9CG,EAASK,OAAOR,IACvBgC,EAGEoC,KAAO,WACT1E,IACAoC,IAEAb,EAAMC,OAAOW,KAAQT,EAAMC,KAAI,8BAGjCJ,EAAMC,OAAOW,KAAQT,EAAMC,KAAI,KAAKD,EAAMW,QAAO,YAG1Cd,EAAM+C,OAAOhC,EAAKf,IAG3BzB,OAAOiD,OAAShD,SClOhBgD,OAAO0B,OAAO,OAAQ,SAAUxE,GAC9B,GAAI0E,IACFC,YACIC,KAAM,IAAKC,KAAM,SACjBD,KAAM,aAAcC,KAAM,cAC1BD,KAAM,wBAAyBC,KAAM,SAAUC,QAAQ,IAI7D9E,GAAUC,IAAI8E,UAAYjC,OAAOkC,UAAUC,YAAYP,KCLzD5B,OAAO0B,OAAO,UAAW,SAAUxE,GAe/B,QAGOkF,GAASxD,EAAMyD,GAEtB,MAA8B,gBAAnBA,GAAUP,SACnB9B,QAAOvB,OAAOkB,KAAI,UAAWf,EAAI,qDAKT,MAAtByD,EAAUP,KAAK,KACjBO,EAAUP,KAAI,IAAOO,EAAUP,WAChCQ,EAGM1D,GAAQyD,IAChB,QAGQE,GAAaF,GACpB,MAAOD,GAAS,UAAWpC,OAAOuB,OAAOc,GAAaP,KAAM,OAC7D,QAGQU,GAAeV,GACtB,GAAIW,GAAK5D,MAWT,OATArB,QAAOM,KAAKwE,GAAQI,MAAM,SAACC,GACzB,MAAIL,GAAOK,GAAWb,OAASA,GAC7BW,EAAQH,EAAOK,IACR,IAGF,IAGFF,EACR,QAGQG,GAAaH,GACpBzC,OAAOvB,OAAOe,IAAG,kBAAmBiD,EAAMX,KAAI,IAAKW,GAvDrD,GAAIH,IACFO,MACEf,KAAM,IACNgB,WAAY,iBACZC,OAAQ,OACRC,SAAU,QAEZC,WACEnB,KAAM,aACNgB,WAAY,sBACZC,OAAQ,QACRC,SAAU,aAiEX,OApBFhD,QAGMW,UAAUzD,EAAUC,IAAK,QAAS,IAAK,SAAUmD,GACpD,GAAKA,EAAEe,OAAO6B,aAAa,QAA3B,CAIA,GAAIC,GAAcX,EAAelC,EAAEe,OAAO+B,aAAa,QAEnDD,KACF7C,EAAE+C,iBACFC,QAAQC,WAAYd,MAAOU,GAAe,GAAIA,EAAYrB,MAC1Dc,EAAaO,OAEhBnD,OAGIW,UAAU5D,OAAQ,WAAY,SAAUuD,GAC7CsC,EAAatC,EAAEkD,MAAMf,UAKrBgB,KAAMrB,EACNsB,UAAWnB","file":"application.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nwindow.Zframe = function () {\n  var _info = {\n    name: 'Zframe',\n    version: '0.0.0'\n  };\n  var _data = {};\n  var _cache = {};\n  var _modules = {\n    loaded: {},\n    unloaded: {},\n    scopes: {}\n  };\n  var _fn = {};\n  var _elements = {};\n\n  var utils = {};\n  var ret = {};\n\n  function cacheElements() {\n    _elements.app = document.getElementById('app');\n  }\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    var modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      var modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if ((typeof modData === 'undefined' ? 'undefined' : _typeof(modData)) !== \"object\") {\n      utils.logger.error(_info.name + ' module \\'' + modName + '\\' could not be loaded.');\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    var dependencies = [_elements];\n\n    // TODO: handle 'call stack exceeded' if it shows up\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach(function (depName, i) {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            utils.logger.error(_info.name + ' module \\'' + modName + '\\' dependency \\'' + depName + '\\' is not a registered module.');\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    utils.logger.info(_info.name + ' module \\'' + modName + '\\' loaded!');\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach(function (modName) {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  utils.logger = {\n    log: function log() {\n      console.log.apply(console, arguments);\n    },\n    info: function info() {\n      console.info.apply(console, arguments);\n    },\n    warn: function warn() {\n      console.warn.apply(console, arguments);\n    },\n    error: function error() {\n      console.error.apply(console, arguments);\n    },\n    table: function table() {\n      console.table.apply(console, arguments);\n    }\n  };\n\n  // TODO: write xhr utility\n  utils.xhr = function () {\n    return function (options) {\n      if (typeof options === \"string\") {\n        options = {\n          url: options\n        };\n      }\n\n      zframe.logger.info('Performing XHR to ' + options.url + ' here');\n    };\n  };\n\n  utils.trigger = function (el, evtType, spec) {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    var e = new Event(evtType, {\n      bubbles: false,\n      cancelable: false\n    });\n\n    el.dispatchEvent(e);\n  };\n\n  // Binds an event to an element, support delegation\n  utils.bindEvent = function (el, evtType, spec, fn) {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    if (fn === undefined) {\n      if (typeof spec === \"function\") {\n        fn = spec;\n      } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === \"object\") {\n        fn = spec.fn;\n      }\n    }\n\n    var q = undefined;\n\n    if (typeof spec === \"string\") {\n      q = spec;\n    } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === \"object\") {\n      q = spec.query;\n    }\n\n    if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === undefined) {\n      app.logger.error(_info.name + ' couldn\\'t find an event to bind');\n    }\n\n    if (q === undefined) {\n      el.addEventListener(evtType, fn);\n    } else {\n      el.addEventListener(evtType, function (e) {\n        var qMatches = Array.prototype.slice.call(el.querySelectorAll(q));\n        if (qMatches.indexOf(e.target) !== -1) {\n          fn.apply(this, arguments);\n        }\n      });\n    }\n  };\n\n  // Add the properties of one object to another, shallow copy\n  utils.extend = function (obj1, obj2) {\n    if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach(function (key) {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  ret.module = function (modName, modData) {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        utils.logger.warn(_info.name + ' module \\'' + modName + '\\' already registered for loading.');\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return _modules.unloaded[modName];\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      utils.logger.error(_info.name + ' module \\'' + modName + '\\' doesn\\'t exist.');\n      return;\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Initializes all of the modules\n  ret.init = function () {\n    cacheElements();\n    loadModules();\n\n    utils.logger.info(_info.name + ' initialization complete.');\n  };\n\n  utils.logger.info(_info.name + ' v' + _info.version + ' loaded!');\n\n  // Combine utility functions into the return object for use in modules\n  return utils.extend(ret, utils);\n};\n\nwindow.zframe = Zframe();\n'use strict';\n\nzframe.module('main', function (_elements) {\n  var data = {\n    menuItems: [{ path: '/', text: 'home' }, { path: '/portfolio', text: 'portfolio' }, { path: 'http://www.google.com', text: 'Google', remote: true }]\n  };\n\n  _elements.app.innerHTML = zframe.Templates.application(data);\n});\n'use strict';\n\n/**\n * Verbiage note: \"routeSpec\" is the route definition BEFORE adding to routes, still allowed to be changed\n * \"route\" is the route definition as returned from the routes hash, not allowed to be modified at this point\n */\nzframe.module('zRouter', function (_elements) {\n  // Hash of all app routes\n  var routes = {\n    'home': {\n      path: '/',\n      controller: 'homeController',\n      action: 'show',\n      template: 'home'\n    },\n    'portfolio': {\n      path: '/portfolio',\n      controller: 'portfolioController',\n      action: 'index',\n      template: 'portfolio'\n    }\n  };\n\n  // Pushes a routeSpec into the routes hash with specified name\n  function addRoute(name, routeSpec) {\n    // Early return if path isn't a string\n    if (typeof routeSpec.path !== 'string') {\n      zframe.logger.warn('Route \\'' + name + '\\' couldn\\'t be added, path couldn\\'t be processed.');\n      return;\n    }\n\n    // prepend a slash to path if it doesn't already start with one\n    if (routeSpec.path[0] !== '/') {\n      routeSpec.path = '/' + routeSpec.path;\n    }\n\n    // add routeSpec to routes hash\n    routes[name] = routeSpec;\n  }\n\n  // Pushes a routeSpec object into the routes hash with a path of /\n  function defaultRoute(routeSpec) {\n    return addRoute('default', zframe.extend(routeSpec, { path: '/' }));\n  }\n\n  // Returns the first route that matches a path\n  function getRouteByPath(path) {\n    var route = undefined;\n\n    Object.keys(routes).every(function (routeName) {\n      if (routes[routeName].path === path) {\n        route = routes[routeName];\n        return false;\n      }\n\n      return true;\n    });\n\n    return route;\n  }\n\n  // TODO: Processes a route object and routes the user accordingly\n  function processRoute(route) {\n    zframe.logger.log('Process route \\'' + route.path + '\\'', route);\n  }\n\n  // Bind to all link clicks\n  zframe.bindEvent(_elements.app, 'click', 'a', function (e) {\n    if (!e.target.hasAttribute('href')) {\n      return;\n    }\n\n    var targetRoute = getRouteByPath(e.target.getAttribute('href'));\n\n    if (targetRoute) {\n      e.preventDefault();\n      history.pushState({ route: targetRoute }, '', targetRoute.path);\n      processRoute(targetRoute);\n    }\n  });\n\n  // Bind the popstate event and process routes\n  zframe.bindEvent(window, 'popstate', function (e) {\n    processRoute(e.state.route);\n  });\n\n  // Return the public methods\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});","window.Zframe = function () {\n  let _info = {\n    name: 'Zframe',\n    version: '0.0.0'\n  };\n  let _data = {};\n  let _cache = {};\n  let _modules = {\n    loaded: {},\n    unloaded: {},\n    scopes: {}\n  };\n  let _fn = {};\n  let _elements = {};\n\n  let utils = {};\n  let ret = {};\n\n  function cacheElements() {\n    _elements.app = document.getElementById('app');\n  }\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    let modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      let modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if (typeof modData !== \"object\") {\n      utils.logger.error(`${_info.name} module '${modName}' could not be loaded.`);\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    let dependencies = [_elements];\n\n    // TODO: handle 'call stack exceeded' if it shows up\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach((depName, i) => {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            utils.logger.error(`${_info.name} module '${modName}' dependency '${depName}' is not a registered module.`);\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    utils.logger.info(`${_info.name} module '${modName}' loaded!`);\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach((modName) => {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  utils.logger = {\n    log: function () {\n      console.log.apply(console, arguments);\n    },\n    info: function () {\n      console.info.apply(console, arguments);\n    },\n    warn: function () {\n      console.warn.apply(console, arguments);\n    },\n    error: function () {\n      console.error.apply(console, arguments);\n    },\n    table: function () {\n      console.table.apply(console, arguments);\n    },\n  };\n\n  // TODO: write xhr utility\n  utils.xhr = () => {\n    return (options) => {\n      if (typeof options === \"string\") {\n        options = {\n          url: options\n        };\n      }\n\n      zframe.logger.info(`Performing XHR to ${options.url} here`);\n    };\n  };\n\n  utils.trigger = (el, evtType, spec) => {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    let e = new Event(evtType, {\n      bubbles: false,\n      cancelable: false\n    });\n\n    el.dispatchEvent(e);\n  };\n\n  // Binds an event to an element, support delegation\n  utils.bindEvent = (el, evtType, spec, fn) => {\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n\n    if (fn === undefined) {\n      if (typeof spec === \"function\") {\n        fn = spec;\n      } else if (typeof spec === \"object\") {\n        fn = spec.fn;\n      }\n    }\n\n    let q;\n\n    if (typeof spec === \"string\") {\n      q = spec;\n    } else if (typeof spec === \"object\"){\n      q = spec.query;\n    }\n\n    if (typeof fn === undefined) {\n      app.logger.error(`${_info.name} couldn't find an event to bind`);\n    }\n\n    if (q === undefined) {\n      el.addEventListener(evtType, fn);\n    } else {\n      el.addEventListener(evtType, function (e) {\n        let qMatches = Array.prototype.slice.call(el.querySelectorAll(q));\n        if (qMatches.indexOf(e.target) !== -1) {\n          fn.apply(this, arguments);\n        }\n      });\n    }\n  };\n\n  // Add the properties of one object to another, shallow copy\n  utils.extend = (obj1, obj2) => {\n    if (typeof obj2 !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach((key) => {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  ret.module = (modName, modData) => {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        utils.logger.warn(`${_info.name} module '${modName}' already registered for loading.`);\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return _modules.unloaded[modName];\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      utils.logger.error(`${_info.name} module '${modName}' doesn't exist.`);\n      return;\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Initializes all of the modules\n  ret.init = () => {\n    cacheElements();\n    loadModules();\n\n    utils.logger.info(`${_info.name} initialization complete.`);\n  };\n\n  utils.logger.info(`${_info.name} v${_info.version} loaded!`);\n\n  // Combine utility functions into the return object for use in modules\n  return utils.extend(ret, utils);\n};\n\nwindow.zframe = Zframe();\n","zframe.module('main', function (_elements) {\n  let data = {\n    menuItems: [\n      { path: '/', text: 'home' },\n      { path: '/portfolio', text: 'portfolio' },\n      { path: 'http://www.google.com', text: 'Google', remote: true}\n    ]\n  };\n\n  _elements.app.innerHTML = zframe.Templates.application(data);\n});\n","/**\n * Verbiage note: \"routeSpec\" is the route definition BEFORE adding to routes, still allowed to be changed\n * \"route\" is the route definition as returned from the routes hash, not allowed to be modified at this point\n */\nzframe.module('zRouter', function (_elements) {\n  // Hash of all app routes\n  let routes = {\n    'home': {\n      path: '/',\n      controller: 'homeController',\n      action: 'show',\n      template: 'home'\n    },\n    'portfolio': {\n      path: '/portfolio',\n      controller: 'portfolioController',\n      action: 'index',\n      template: 'portfolio'\n    }\n  };\n\n  // Pushes a routeSpec into the routes hash with specified name\n  function addRoute(name, routeSpec) {\n    // Early return if path isn't a string\n    if (typeof routeSpec.path !== 'string') {\n      zframe.logger.warn(`Route '${name}' couldn't be added, path couldn't be processed.`);\n      return;\n    }\n\n    // prepend a slash to path if it doesn't already start with one\n    if (routeSpec.path[0] !== '/') {\n      routeSpec.path = `/${routeSpec.path}`;\n    }\n\n    // add routeSpec to routes hash\n    routes[name] = routeSpec;\n  }\n\n  // Pushes a routeSpec object into the routes hash with a path of /\n  function defaultRoute(routeSpec) {\n    return addRoute('default', zframe.extend(routeSpec, { path: '/' }));\n  }\n\n  // Returns the first route that matches a path\n  function getRouteByPath(path) {\n    let route;\n\n    Object.keys(routes).every((routeName) => {\n      if (routes[routeName].path === path) {\n        route = routes[routeName];\n        return false;\n      }\n\n      return true;\n    });\n\n    return route;\n  }\n\n  // TODO: Processes a route object and routes the user accordingly\n  function processRoute(route) {\n    zframe.logger.log(`Process route '${route.path}'`, route);\n  }\n\n  // Bind to all link clicks\n  zframe.bindEvent(_elements.app, 'click', 'a', function (e) {\n      if (!e.target.hasAttribute('href')) {\n        return;\n      }\n\n      let targetRoute = getRouteByPath(e.target.getAttribute('href'));\n\n      if (targetRoute) {\n        e.preventDefault();\n        history.pushState({ route: targetRoute }, '', targetRoute.path);\n        processRoute(targetRoute);\n      }\n  });\n\n  // Bind the popstate event and process routes\n  zframe.bindEvent(window, 'popstate', function (e) {\n    processRoute(e.state.route);\n  });\n\n  // Return the public methods\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});\n"],"sourceRoot":"/source/"}