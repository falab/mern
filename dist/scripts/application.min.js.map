{"version":3,"sources":["application.min.js","zframe.js","main.js","router.js","utilities/xhr.js"],"names":["_typeof","Symbol","iterator","obj","constructor","window","Zframe","moduleRegistered","modName","Object","key","_modules","unloaded","indexOf","moduleLoaded","keys","loaded","loadModule","modData","fn","scope","hasOwnProperty","modFn","pop","dependencies","utils","logger","error","_info","name","undefined","forEach","depName","i","push","scopes","apply","info","loadModules","version","ret","log","console","arguments","warn","table","extend","obj1","obj2","module","init","zframe","appContainer","document","getElementById","data","menuItems","path","text","remote","innerHTML","Templates","application","routes","addRoute","spec","defaultRoute","when","otherwise","options","url"],"mappings":"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","file":"application.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nwindow.Zframe = function () {\n  var _info = {\n    name: 'Zframe',\n    version: '0.0.0'\n  },\n      _data = {},\n      _cache = {},\n      _modules = {\n    loaded: {},\n    unloaded: {},\n    scopes: {}\n  },\n      _fn = {},\n      utils = {},\n      ret = {};\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    var modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      var modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if ((typeof modData === 'undefined' ? 'undefined' : _typeof(modData)) !== \"object\") {\n      utils.logger.error(_info.name + ' module \\'' + modName + '\\' could not be loaded.');\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    var dependencies = [];\n\n    // TODO: handle 'call stack exceeded'\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach(function (depName, i) {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            utils.logger.error(_info.name + ' module \\'' + modName + '\\' dependency \\'' + depName + '\\' is not a registered module.');\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    utils.logger.info(_info.name + ' module \\'' + modName + '\\' loaded!');\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach(function (modName) {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  utils.logger = {\n    log: function log() {\n      console.log.apply(console, arguments);\n    },\n    info: function info() {\n      console.info.apply(console, arguments);\n    },\n    warn: function warn() {\n      console.warn.apply(console, arguments);\n    },\n    error: function error() {\n      console.error.apply(console, arguments);\n    },\n    table: function table() {\n      console.table.apply(console, arguments);\n    }\n  };\n\n  // Add the properties of one object to another, shallow copy\n  utils.extend = function (obj1, obj2) {\n    if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach(function (key) {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  ret.module = function (modName, modData) {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        utils.logger.warn(_info.name + ' module \\'' + modName + '\\' already registered for loading.');\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return _modules.unloaded[modName];\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      utils.logger.error(_info.name + ' module \\'' + modName + '\\' doesn\\'t exist.');\n      return;\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Initializes all of the modules\n  ret.init = function () {\n    loadModules();\n    utils.logger.info(_info.name + ' initialization complete.');\n  };\n\n  utils.logger.info(_info.name + ' v' + _info.version + ' loaded!');\n\n  // Combine utility functions into the return object for use in modules\n  return utils.extend(ret, utils);\n};\n\nwindow.zframe = Zframe();\n'use strict';\n\nzframe.module('main', function () {\n  var appContainer = document.getElementById('app');\n\n  var data = {\n    menuItems: [{ path: '/', text: 'home' }, { path: '/portfolio', text: 'portfolio' }, { path: 'http://www.google.com', text: 'Google', remote: true }]\n  };\n\n  appContainer.innerHTML = zframe.Templates.application(data);\n});\n'use strict';\n\nzframe.module('router', function () {\n  var routes = [];\n\n  var addRoute = function addRoute(path, spec) {\n    routes[path] = spec;\n  };\n\n  var defaultRoute = function defaultRoute(spec) {\n    return addRoute('/', spec);\n  };\n\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});\n\"use strict\";\n\nzframe.module('xhr', function () {\n  return function (options) {\n    if (typeof options === \"string\") {\n      options = {\n        url: options\n      };\n    }\n\n    zframe.logger.info(\"Performing XHR to \" + options.url + \" here\");\n  };\n});","window.Zframe = function () {\n  let _info = {\n      name: 'Zframe',\n      version: '0.0.0'\n    },\n    _data = {},\n    _cache = {},\n    _modules = {\n      loaded: {},\n      unloaded: {},\n      scopes: {}\n    },\n    _fn = {},\n    utils = {},\n    ret = {};\n\n  // Check if a module is registered for loading\n  function moduleRegistered(modName) {\n    return Object.key(_modules.unloaded).indexOf(modName) > -1;\n  }\n\n  // Check if a module has been loaded\n  function moduleLoaded(modName) {\n    return Object.keys(_modules.loaded).indexOf(modName) > -1;\n  }\n\n  // load a module\n  function loadModule(modName) {\n    let modData = _modules.unloaded[modName];\n\n    if (typeof modData === 'function') {\n      modData = {\n        fn: modData,\n        scope: {}\n      };\n    } else if (modData.hasOwnProperty('length')) {\n      let modFn = modData.pop();\n\n      modData = {\n        fn: modFn,\n        dependencies: modData,\n        scope: {}\n      };\n    } else if (typeof modData !== \"object\") {\n      utils.logger.error(`${_info.name} module '${modName}' could not be loaded.`);\n      return;\n    }\n\n    if (!modData.hasOwnProperty('scope')) {\n      modData.scope = {};\n    }\n\n    let dependencies = [];\n\n    // TODO: handle 'call stack exceeded'\n    if (modData.dependencies !== undefined) {\n      modData.dependencies.forEach((depName, i) => {\n        if (!moduleLoaded(depName)) {\n          if (!moduleRegistered) {\n            utils.logger.error(`${_info.name} module '${modName}' dependency '${depName}' is not a registered module.`);\n            return;\n          }\n\n          loadModule(depName);\n          dependencies.push(_modules.loaded[depName]);\n        }\n      });\n    }\n\n    _modules.scopes[modName] = modData.scope;\n    _modules.loaded[modName] = modData.fn.apply(modData.scope, dependencies);\n\n    utils.logger.info(`${_info.name} module '${modName}' loaded!`);\n\n    delete _modules.unloaded[name];\n  }\n\n  // Load all unloaded modules\n  function loadModules() {\n    Object.keys(_modules.unloaded).forEach((modName) => {\n      if (!moduleLoaded(modName)) {\n        loadModule(modName);\n      }\n    });\n  }\n\n  // Abstract logging for later\n  // TODO: create custom logging\n  utils.logger = {\n    log: function () {\n      console.log.apply(console, arguments);\n    },\n    info: function () {\n      console.info.apply(console, arguments);\n    },\n    warn: function () {\n      console.warn.apply(console, arguments);\n    },\n    error: function () {\n      console.error.apply(console, arguments);\n    },\n    table: function () {\n      console.table.apply(console, arguments);\n    },\n  };\n\n  // Add the properties of one object to another, shallow copy\n  utils.extend = (obj1, obj2) => {\n    if (typeof obj2 !== 'object') {\n      return;\n    }\n\n    Object.keys(obj2).forEach((key) => {\n      obj1[key] = obj2[key];\n    });\n\n    return obj1;\n  };\n\n  // When passed only a modName, returns module\n  // when passed modName and modData, registers a module for loading\n  ret.module = (modName, modData) => {\n    // If modData is passed, register and return unloaded module\n    if (modData !== undefined) {\n      if (Object.keys(_modules.unloaded).indexOf(modName) !== -1) {\n        utils.logger.warn(`${_info.name} module '${modName}' already registered for loading.`);\n      } else {\n        _modules.unloaded[modName] = modData;\n      }\n\n      return _modules.unloaded[modName];\n    }\n\n    // If modData is not passed return loaded module\n    if (Object.keys(_modules.loaded).indexOf(modName) === -1) {\n      utils.logger.error(`${_info.name} module '${modName}' doesn't exist.`);\n      return;\n    }\n\n    return _modules.loaded[modName];\n  };\n\n  // Initializes all of the modules\n  ret.init = () => {\n    loadModules();\n    utils.logger.info(`${_info.name} initialization complete.`);\n  };\n\n  utils.logger.info(`${_info.name} v${_info.version} loaded!`);\n\n  // Combine utility functions into the return object for use in modules\n  return utils.extend(ret, utils);\n};\n\nwindow.zframe = Zframe();\n","zframe.module('main', () => {\n  let appContainer = document.getElementById('app');\n\n  let data = {\n    menuItems: [\n      { path: '/', text: 'home' },\n      { path: '/portfolio', text: 'portfolio' },\n      { path: 'http://www.google.com', text: 'Google', remote: true}\n    ]\n  };\n\n  appContainer.innerHTML = zframe.Templates.application(data);\n});\n","zframe.module('router', () => {\n  let routes = [];\n\n  let addRoute = (path, spec) => {\n    routes[path] = spec;\n  };\n\n  let defaultRoute = (spec) => {\n    return addRoute('/', spec);\n  };\n\n  return {\n    when: addRoute,\n    otherwise: defaultRoute\n  };\n});\n","zframe.module('xhr', function () {\n  return (options) => {\n    if (typeof options === \"string\") {\n      options = {\n        url: options\n      };\n    }\n\n    zframe.logger.info(`Performing XHR to ${options.url} here`);\n  };\n});\n"],"sourceRoot":"/source/"}